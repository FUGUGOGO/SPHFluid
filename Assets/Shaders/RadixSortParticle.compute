#include "SPHInclude.compute"
#pragma kernel CheckOrder
#pragma kernel LocalSort
#pragma kernel GlobalReorder

#define SORT_SECTION_SIZE 16
#define SORT_SECTION_SIZE_2D 256
#define BITS_PER_ROTATION 4
#define BITS_MASK 15
#define BUCKET_SIZE 16

//Input
uint _RotationRound; //need to be set every round
StructuredBuffer<Particle> _Particles;

//Update
RWBuffer<uint> _Ordered; //need to be initialized as true
groupshared uint _GroupBucket[BUCKET_SIZE];
groupshared uint _GroupContainer[SORT_SECTION_SIZE_2D];
RWBuffer<uint> _GlobalPrefixSum; //[BUCKET_SIZE]; //need to be initialized as all zeros
RWBuffer<uint> _LocalPrefixSum; //[BUCKET_SIZE * Group number], need to be initialized as all zeros
//Output
RWStructuredBuffer<Particle> _SortedParticles;

[numthreads(SORT_SECTION_SIZE,SORT_SECTION_SIZE,1)]
void CheckOrder (uint groupIdx : SV_GroupIndex, uint3 groupId :SV_GroupID)
{
	uint flatIdx = groupIdx + groupId.x * SORT_SECTION_SIZE_2D;
	if(flatIdx >= _ParticleNum - 1)
		return;
	
	if(_Particles[flatIdx]._cellIdx1d > _Particles[flatIdx]._cellIdx1d + 1)
		InterlockedAnd(_Ordered[0], 0);
}


[numthreads(SORT_SECTION_SIZE,SORT_SECTION_SIZE,1)]
void LocalSort (uint groupIdx : SV_GroupIndex, uint3 groupId :SV_GroupID)
{
	if(groupIdx == 0)
	{
		for(int i = 0; i < BUCKET_SIZE; ++i)
			_GroupBucket[i] = 0;
	}
	if(groupId.x == 0)
		_GroupContainer[groupIdx] = 0;
	GroupMemoryBarrierWithGroupSync();

	uint flatIdx = groupIdx + groupId.x * SORT_SECTION_SIZE_2D;	
	uint bin = 0;
	if(flatIdx < _ParticleNum)
	{
		//generate local histogram
		bin = (_Particles[flatIdx]._cellIdx1d >> (_RotationRound * BITS_PER_ROTATION)) & BITS_MASK;
		InterlockedAdd(_GroupBucket[bin], 1);
	}
	GroupMemoryBarrierWithGroupSync();
	
	if(groupIdx == 0)
	{
		//compute local prefix sum
		uint counter = 0;
		for(int i = 0; i < BUCKET_SIZE; ++i)
		{
			uint oldVal = _GroupBucket[i];
			_GroupBucket[i] = counter;
			InterlockedAdd(_GlobalPrefixSum[i], _GroupBucket[i]);
			_LocalPrefixSum[BUCKET_SIZE * groupId.x + i] = _GroupBucket[i];
			counter += oldVal;
		}
	}
	GroupMemoryBarrierWithGroupSync();

	if(flatIdx < _ParticleNum)
	{
		//local sort
		uint binCursor;
		InterlockedAdd( _GroupBucket[bin], 1, binCursor);
		_GroupContainer[binCursor] = flatIdx;
	}
	GroupMemoryBarrierWithGroupSync();

	if(flatIdx < _ParticleNum)
		_SortedParticles[flatIdx] = _Particles[_GroupContainer[groupIdx]];
}

[numthreads(SORT_SECTION_SIZE,SORT_SECTION_SIZE,1)]
void GlobalReorder (uint groupIdx : SV_GroupIndex, uint3 groupId :SV_GroupID)
{
	
}